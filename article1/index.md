# Compilers

[mov (2013)](https://stackoverflow.com/questions/61048788/why-is-mov-turing-complete) and [movfuscator (2015).](https://github.com/Battelle/movfuscator) Scheme, Smalltalk, Tcl... are minimal programming languages, but mov is even simpler.

[Ark (2015):](https://github.com/ark-lang/ark) LLVM, FFI to C with an OpenGL demo.

[mini-js (2017):](https://github.com/maierfelix/mini-js/tree/master) "Minimal self-hosted JavaScript compiler in 1k lines of code."

[Monkey (2018):](https://github.com/search?q=monkey+compiler) Stack-based bytecode VM.

[Mugo (2021):](https://benhoyt.com/writings/mugo/) Targets x86-64 assembly, compiles itself.

[The Art of Code (2022).](https://www.youtube.com/watch?v=gwLQMuTspxE) Some other systems like John Conway's Game of Life.

Complex problems that have no answers, and every God damn decade is the same: null, [generics](https://nim-lang.org/docs/tut2.html#generics), [templates](https://nim-lang.org/docs/tut2.html#templates), [macros](https://nim-lang.org/docs/tut3.html), [pragmas](https://nim-lang.org/docs/manual.html#pragmas), 3D backends, FFI to C, HTML templates, ORMs, C/C++ modules, build systems, system paths, packages (Make and CMake).

Solid languages, horrid ecosystems (too much focus on type theory): [F#](https://danielbachler.de/2020/12/23/what-i-wish-i-knew-when-learning-fsharp.html), OCaml (see [the comment](https://news.ycombinator.com/item?id=29581112) by wk_end).
