<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Ramunas Girdziusas">
    <meta name="keywords" content="programming, blog">
    <title>Blog Articles</title>
    <link rel="icon" href="imgs/rg.jpg">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="container">
        <h1 class="title">Blog</h1>
        
<div class="article">
    <h2>Parser/Compiler Links</h2>
    <div class="summary"><p>There is a lot of heavy compiler theory that people study for years. I will add a few practical links here to get one started.</p>
</div>
    <div class="content"><p>There is a lot of heavy compiler theory that people study for years. I will add a few practical links here to get one started.</p>

<p><a href="https://github.com/ark-lang/ark">Ark (2015):</a> A static non-GC language written with Go and LLVM: FFI to C, OpenGL demo.</p>

<p><a href="https://github.com/maierfelix/mini-js/tree/master">mini-js (2017):</a> &ldquo;Minimal self-hosted JavaScript compiler in 1k lines of code.&rdquo;</p>

<p><a href="https://github.com/search?q=monkey+interpreter">Monkey (2018):</a> A minimal Js-like language implemented with a recursive descent parser, in Go. Lots of following!</p>

<p><a href="https://benhoyt.com/writings/mugo/">Mugo (2021):</a> A subset of Go compiled to the x86-64 assembly, in Go.</p>

<p><a href="https://www.youtube.com/watch?v=gwLQMuTspxE">The Art of Code (2022).</a> One of the most beautiful and entertaining presentations about computing models and programming languages.</p>

<p><a href="https://stackoverflow.com/questions/61048788/why-is-mov-turing-complete">mov (2013)</a> and <a href="https://github.com/Battelle/movfuscator">movfuscator (2015).</a> One of the remarkable brain twisters.</p>
</div>
    <span class="read-more">Read more</span>
</div>

<div class="article">
    <h2>My Ubuntu Experience</h2>
    <div class="summary"><p>I began using Ubuntu around 2010. Tried Arch Linux without much joy soon afterwards, then a year with Fedora, and another year with macOS (OS X Lion). Since 2014 I solely use Ubuntu:</p>
</div>
    <div class="content"><p>I began using Ubuntu around 2010. Tried Arch Linux without much joy soon afterwards, then a year with Fedora, and another year with macOS (OS X Lion). Since 2014 I solely use Ubuntu:</p>

<ul>
<li><p>Every time there is some major version change somewhere in these desktop GUI technologies, expect bugs and even black screens. What works well is a dual HD/SSD drive setup where most of your data will reside on a slow HD and the system on a faster SSD, with an Ubuntu USB stick nearby to reinstall the whole thing.</p></li>

<li><p>Contrary to common suggestions, &ldquo;sudo apt upgrade&rdquo; should never be run. It is very fragile. If there is a network glitch or you accidentally cancel the upgrade, you may lose the whole desktop environment or something equally bad like the network/sound drivers.</p></li>

<li><p>It is almost never a good idea to install a freshly released new major Ubuntu version unless you want to be an unpaid beta tester. I was tempted to try out the new 24.04 only to find out so many bugs. Went back to 22.04. It is good to wait for a year or two. Do not trust any happy youtubers discussing &ldquo;amazing recent releases&rdquo;. Most of these &ldquo;indies&rdquo; are affiliated with the product owners by now or rush their videos without deeper testing.</p></li>

<li><p>Many Windows-centric programs won&rsquo;t work even if they claim to have Linux/Ubuntu ports for some time. In my experience, Unreal 4 was crashing all the time, Unity worked better, but I would not use it either. TomTom with wine is hopeless too.
Whatsapp, Messenger still do not have fully working apps on Ubuntu in the year 2024. Viber runs perfectly natively, kudos to them. wine is always a mess. Lately I could not install it without re-enabling Ubuntu updates which I usually disable.</p></li>

<li><p>Remote desktop access is horrid, but it is a difficult problem. Remmina won&rsquo;t hole-punch through. I have not tried Connections, but unless it graciously donates some kind of a VPN server behind it, that won&rsquo;t work either. Golibp2p and the Web3 are kind of too slow for this problem.</p></li>

<li><p>It used to be hard to install a full Python pipeline properly with CUDA, around say 2012. Ten years later this is easy with conda. Docker containers are also used a lot.</p></li>
</ul>

<p>In general, Ubuntu is great compared to Windows/macOS. I do not see any need for macOS, but Windows is still important to 3D like running Unity/Unreal, CAD, some of the newest PC games. Other than that, install Ubuntu 22.04 and you will be fine for a decade. Along with Chromium (not Chrome), one can still run youtube and lichess on i3 with an integrated default GPU and &ldquo;only&rdquo; 4GB of RAM. This is the borderline in the year 2024. Better have at least 8GB of RAM for the browser activity.</p>

<p>P.S.</p>

<p>2004 - 2010: GNOME 2.</p>

<p>2011 - 2017: Unity (based on GNOME 3).</p>

<p>2016: Vulkan becomes an option alongside OpenGL.</p>

<p>2017: GNOME 3, Wayland instead of Xorg.</p>

<p>2018 - 2021: GNOME 3, back to Xorg.</p>

<p>2019: NVIDIA drivers out of the box.</p>

<p>2021 - 2023: GNOME 40, Wayland.</p>

<p>2022: dxvk (1.10.3) pushes the ability to play Windows games to <a href="https://github.com/doitsujin/dxvk/issues/3789">another level</a>. Those that rely on the ms-store and xbox libs (Forza Horizon) are still beyond reach.</p>

<p>2023 - 2024: GNOME40, Wayland, Flutter.</p>
</div>
    <span class="read-more">Read more</span>
</div>

<div class="article">
    <h2>Disappointing Projects</h2>
    <div class="summary"><p>So much time is wasted everywhere. I will note a few areas/projects, let&rsquo;s hope they are a necessary transition towards something greater yet to come.</p>
</div>
    <div class="content"><p>So much time is wasted everywhere. I will note a few areas/projects, let&rsquo;s hope they are a necessary transition towards something greater yet to come.</p>

<p>&ldquo;Great ideas&rdquo;: null, pointers, smart pointers, <a href="https://nim-lang.org/docs/tut2.html#generics">generics</a>, <a href="https://nim-lang.org/docs/tut2.html#templates">templates</a>, <a href="https://nim-lang.org/docs/tut3.html">macros</a>, <a href="https://nim-lang.org/docs/manual.html#pragmas">pragmas</a>, all the 3D backends, FFI to C, HTML templates, ORMs, <a href="https://yosefk.com/c++fqa/">C++</a>, &ldquo;design patterns&rdquo;, Windows/Ubuntu updates, GPL licenses, system libs/paths, Make and CMake, &ldquo;homoiconic&rdquo;, <a href="https://en.wikipedia.org/wiki/Design_by_committee">&ldquo;design by a committee&rdquo;</a>, &ldquo;lets reduce everything to OO/FP/Actor/pointers&rdquo;&hellip;</p>

<p>Most of the dynamic languages except maybe Python: Lisp, Smalltalk, <a href="https://iolanguage.org/">io</a>, Tcl, Lua, Ruby, Forth, Prolog, Erlang, Elixir, Julia, Scilab. <a href="https://www.destroyallsoftware.com/talks/wat">Js</a>&hellip;</p>

<p>Most of the static GC-based FP languages: <a href="https://elm-lang.org/news/farewell-to-frp">Elm</a>, ReasonML, <a href="https://danielbachler.de/2020/12/23/what-i-wish-i-knew-when-learning-fsharp.html">F#</a>, OCaml (see <a href="https://news.ycombinator.com/item?id=29581112">the comment</a> by wk_end), Haskell, Idris, Scala&hellip; PEG grammars, parser combinators&hellip; Also <a href="https://www.ponylang.io/">Pony</a>, which is not into the FP per se, but one of the &ldquo;smart ones&rdquo;. Little interesting is ever written in these spaces, so much obsession with type theory that leads nowhere. Elm/ReasonML vs. TypeScript is a good reality check for any PL designer.</p>

<p>&ldquo;Better C/C++&rdquo;, unless you accept Rust with its complexity. Fortran 2023, Pascal, Ada, D, Nim, <a href="https://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/">Rust</a>, Zig, Jai, Odin, <a href="https://github.com/vlang/v">V</a>, Carbon, <a href="https://github.com/pippijn/cyclone">Cyclone</a>, <a href="https://github.com/pervognsen/bitwise/tree/master">Ion</a>, <a href="https://github.com/c2lang/">C2</a>, <a href="https://github.com/c3lang/c3c">C3</a>, <a href="https://github.com/bbu/quaint-lang">Quaint</a>, <a href="https://jakob.space/blog/first-impressions-of-the-myrddin-programming-language.html">Myrddin</a>, <a href="https://github.com/ark-lang/ark">Ark</a>, <a href="https://github.com/carp-lang/Carp">Carp</a>&hellip; A lot of complexity escalates around generic types, none of this helps in 3D in any way. <a href="https://github.com/aabbtree77/twinpeekz2">I like Nim</a>, it has only a &ldquo;gradual complexity&rdquo;, but it fails to get critical mass. Nim is a good example showing that you need a punch line, not just a solid clean up or multiple micro punches, but what do I know. Rust is horrid, but at least it has a borrow checker. Zig goes deeper into isolating and passing around &ldquo;malloc&rdquo;. None of this is really interesting or sufficient to displace anything.</p>

<p>All the big 3D engines: Unity, Unreal, Godot, and <a href="https://www.youtube.com/@gamefromscratch/videos">the rest</a> are beyond hopeless. Imagine you have a lot of man-years, but the problem is, you want to please everyone. So you now have to divide your resources by multiple 3D backends including the newest Vulkan, WebGPU, DX12, MoltenVK, Metal, 2D and 3D, the engine itself and the editor, a scripting language on top, high quality pipeline and reasonable default, games and cinema, mobile, web, online asset stores, license tracking, with the need to communicate and test changes everywhere. Though TBH, it is surprising how much one man with persistence can do, and how cleanly a million lines of C++ (with Vulkan) can compile, see <a href="https://github.com/godlikepanos/anki-3d-engine">AnKi 3D engine</a> by Panagiotis Christopoulos Charitos.</p>

<p>All the GUI frameworks, but I somewhat bet on the web and React. Automated diagram drawing like Mermaid. Figma and <a href="https://github.com/treeform/fidget">Fidget</a>.</p>

<p>All the text editors with debuggers or not, except maybe VS Code: kilo, micro, nano, pico, Vim, Zed, <a href="https://github.com/xi-editor/xi-editor">xi</a>, ddd, <a href="https://documen.tician.de/pudb/">pudb</a>, <a href="https://www.gdbgui.com/">gdbgui</a>, gedit, LiteIDE, GoLand, <a href="https://github.com/eranif/codelite">CodeLite</a>, Geany&hellip; I used to be on the Vim side of things.</p>

<p>Go, esp. after v1.18 which introduced generic types and made it pretty much like everything else now. <a href="https://libp2p.io/implementations/">golibp2p</a> remains an impressive project, but it seems that Go is being overtaken by Rust. Vite (a build tool for React) uses Rollup (Js) and Esbuild (Go), <a href="https://github.com/vitejs/vite/discussions/7622">both are going to be replaced with Rolldown (Rust)</a>.</p>
</div>
    <span class="read-more">Read more</span>
</div>
        <footer class="footer">
            <a href="https://aabbtree77.github.io/" target="_blank">The Old Blog</a>
        </footer>
    </div>
    <script src="js/scripts.js"></script>
</body>
</html>

