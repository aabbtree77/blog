# Disappointing Projects

So much time is wasted everywhere. I will note a few areas/projects, let's hope they are a necessary transition towards something greater yet to come.

"Great ideas": null, pointers, smart pointers, [generics](https://nim-lang.org/docs/tut2.html#generics), [templates](https://nim-lang.org/docs/tut2.html#templates), [macros](https://nim-lang.org/docs/tut3.html), [pragmas](https://nim-lang.org/docs/manual.html#pragmas), all the 3D backends, FFI to C, HTML templates, ORMs, [C++](https://yosefk.com/c++fqa/), "design patterns", Windows/Ubuntu updates, GPL licenses, system libs/paths, Make and CMake, "homoiconic", ["design by a committee"](https://en.wikipedia.org/wiki/Design_by_committee), "lets reduce everything to OO/FP/Actor/pointers"...

Most of the dynamic languages except maybe Python: Lisp, Smalltalk, [io](https://iolanguage.org/), Tcl, Lua, Ruby, Forth, Prolog, Erlang, Elixir, Julia, Scilab. [Js](https://www.destroyallsoftware.com/talks/wat)...

Most of the static GC-based FP languages: [Elm](https://elm-lang.org/news/farewell-to-frp), ReasonML, [F#](https://danielbachler.de/2020/12/23/what-i-wish-i-knew-when-learning-fsharp.html), OCaml (see [the comment](https://news.ycombinator.com/item?id=29581112) by wk_end), Haskell, Idris, Scala... PEG grammars, parser combinators... Also [Pony](https://www.ponylang.io/), which is not into the FP per se, but one of the "smart ones". Little interesting is ever written in these spaces, so much obsession with type theory that leads nowhere. Elm/ReasonML vs. TypeScript is a good reality check for any PL designer.

"Better C/C++", unless you accept Rust with its complexity. Fortran 2023, Pascal, Ada, D, Nim, [Rust](https://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/), Zig, Jai, Odin, [V](https://github.com/vlang/v), Carbon, [Cyclone](https://github.com/pippijn/cyclone), [Ion](https://github.com/pervognsen/bitwise/tree/master), [C2](https://github.com/c2lang/), [C3](https://github.com/c3lang/c3c), [Quaint](https://github.com/bbu/quaint-lang), [Myrddin](https://jakob.space/blog/first-impressions-of-the-myrddin-programming-language.html), [Ark](https://github.com/ark-lang/ark), [Carp](https://github.com/carp-lang/Carp)... A lot of complexity escalates around generic types, none of this helps in 3D in any way. [I like Nim](https://github.com/aabbtree77/twinpeekz2), it has only a "gradual complexity", but it fails to get critical mass. Nim is a good example showing that you need a punch line, not just a solid clean up or multiple micro punches, but what do I know. Rust is horrid, but at least it has a borrow checker. Zig goes deeper into isolating and passing around "malloc". None of this is really interesting or sufficient to displace anything.

All the big 3D engines: Unity, Unreal, Godot, and [the rest](https://www.youtube.com/@gamefromscratch/videos) are beyond hopeless. Imagine you have a lot of man-years, but the problem is, you want to please everyone. So you now have to divide your resources by multiple 3D backends including the newest Vulkan, WebGPU, DX12, MoltenVK, Metal, 2D and 3D, the engine itself and the editor, a scripting language on top, high quality pipeline and reasonable default, games and cinema, mobile, web, online asset stores, license tracking, with the need to communicate and test changes everywhere. Though TBH, it is surprising how much one man with persistence can do, and how cleanly a million lines of C++ (with Vulkan) can compile, see [AnKi 3D engine](https://github.com/godlikepanos/anki-3d-engine) by Panagiotis Christopoulos Charitos.

All the GUI frameworks, but I somewhat bet on the web and React. Automated diagram drawing like Mermaid. Figma and [Fidget](https://github.com/treeform/fidget).

All the text editors with debuggers or not, except maybe VS Code: kilo, micro, nano, pico, Vim, Zed, [xi](https://github.com/xi-editor/xi-editor), ddd, [pudb](https://documen.tician.de/pudb/), [gdbgui](https://www.gdbgui.com/), gedit, LiteIDE, GoLand, [CodeLite](https://github.com/eranif/codelite), Geany... I used to be on the Vim side of things.

Go, esp. after v1.18 which introduced generic types and made it pretty much like everything else now. [golibp2p](https://libp2p.io/implementations/) remains an impressive project, but it seems that Go is being overtaken by Rust. Vite (a build tool for React) uses Rollup (Js) and Esbuild (Go), [both are going to be replaced with Rolldown (Rust)](https://github.com/vitejs/vite/discussions/7622).
